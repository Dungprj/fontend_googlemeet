import React, {
    createContext,
    useState,
    useRef,
    useEffect,
    useCallback
} from 'react';
import Peer from 'peerjs';
import createSignalRConnection from '~/Services/signalRService';
import classNames from 'classnames/bind';
import styles from '~/layouts/components/CallGroup/CallGroup.module.scss';

import $ from 'jquery';
import 'jquery-ui-dist/jquery-ui';
const cx = classNames.bind(styles);
const CallContext = createContext({});

function CallFixProvider({ children }) {
    const [peerId, setPeerId] = useState('');
    const [remotePeers, setRemotePeers] = useState([]); // Danh s√°ch ng∆∞·ªùi ƒë√£ k·∫øt n·ªëi
    const [callParticipants, setCallParticipants] = useState([]); // Danh s√°ch ng∆∞·ªùi trong cu·ªôc g·ªçi
    const [meetingId, setMeetingId] = useState(''); // ID cu·ªôc h·ªçp ƒëang tham gia
    const [meetings, setMeetings] = useState([]); // Danh s√°ch c√°c cu·ªôc h·ªçp
    const peerRef = useRef(null); //ok
    const signalRRef = useRef(null); //ok
    const localStreamRef = useRef(null); //ok
    const videoRefs = useRef([]); //ok
    const videoContainerRef = useRef(null); // useRef ƒë·ªÉ qu·∫£n l√Ω container video ok

    //ki·ªÉm tra bƒÉng th√¥ng
    const checkXirsysBandwidth = async () => {
        try {
            const response = await fetch('https://global.xirsys.net/stat', {
                method: 'GET',
                headers: {
                    Authorization:
                        'Basic ' +
                        btoa('Dungak48:22b52a34-e3db-11ef-af77-0242ac130002'),
                    'Content-Type': 'application/json'
                }
            });

            if (!response.ok)
                throw new Error(
                    '‚ùå Kh√¥ng th·ªÉ l·∫•y th√¥ng tin bƒÉng th√¥ng t·ª´ Xirsys'
                );

            const data = await response.json();
            console.log('‚úÖ D·ªØ li·ªáu bƒÉng th√¥ng Xirsys:', data);
            return data; // Tr·∫£ v·ªÅ th√¥ng tin bƒÉng th√¥ng
        } catch (error) {
            console.error('‚ö†Ô∏è L·ªói khi ki·ªÉm tra bƒÉng th√¥ng:', error);
            return null; // Tr·∫£ v·ªÅ null n·∫øu th·∫•t b·∫°i
        }
    };

    //l·∫•y danh s√°ch iceserver t·ª´ api
    const getIceServersFromXirsys = async () => {
        try {
            const response = await fetch(
                'https://global.xirsys.net/_turn/MyFirstApp',
                {
                    method: 'PUT', // API y√™u c·∫ßu ph∆∞∆°ng th·ª©c PUT
                    headers: {
                        Authorization:
                            'Basic ' +
                            btoa(
                                'Dungak47:b8163796-e0a5-11ef-9dd3-0242ac130002'
                            ),
                        'Content-Type': 'application/json'
                    }
                }
            );

            if (!response.ok)
                throw new Error('‚ùå L·ªói khi l·∫•y ICE servers t·ª´ Xirsys');

            const data = await response.json();
            console.log('‚úÖ ICE Servers nh·∫≠n t·ª´ Xirsys:', data.v.iceServers);
            checkXirsysBandwidth().then(data => {
                if (data) {
                    console.log(
                        `üìä T·ªïng bƒÉng th√¥ng ƒë√£ s·ª≠ d·ª•ng: ${data.v.bytesUsed} bytes`
                    );
                    console.log(
                        `üìâ BƒÉng th√¥ng c√≤n l·∫°i: ${data.v.bytesRemaining} bytes`
                    );
                } else {
                    console.log('‚ö†Ô∏è Kh√¥ng th·ªÉ l·∫•y d·ªØ li·ªáu bƒÉng th√¥ng.');
                }
            });
            return data.v.iceServers; // Tr·∫£ v·ªÅ danh s√°ch ICE servers
        } catch (error) {
            console.error('‚ö†Ô∏è Kh√¥ng th·ªÉ l·∫•y ICE servers:', error);
            return []; // Tr·∫£ v·ªÅ m·∫£ng r·ªóng n·∫øu th·∫•t b·∫°i
        }
    };

    useEffect(() => {
        let peer = null;

        //kh·ªüi t·∫°o PeerJS v√† l·∫•y connectionId t·ª´ SignalR

        const handleReceiveConnectionId = async connectionId => {
            console.log(
                `üîó Nh·∫≠n SignalR ID, s·ª≠ d·ª•ng l√†m Peer ID: ${connectionId}`
            );

            setPeerId(connectionId);

            // G·ªçi API l·∫•y danh s√°ch ICE Servers t·ª´ Xirsys
            const iceServers = await getIceServersFromXirsys();

            // C·∫•u h√¨nh ICE Servers t·ª´ Xirsys
            const peerConfig = {
                config: {
                    iceServers: iceServers
                }
            };

            // Kh·ªüi t·∫°o PeerJS v·ªõi ICE Server
            peer = new Peer(connectionId, peerConfig);
            peerRef.current = peer;

            peer.on('open', async id => {
                console.log(`‚úÖ PeerJS ƒë√£ kh·ªüi t·∫°o v·ªõi ID: ${id}`);
                setPeerId(id);
                // Ki·ªÉm tra xem c√≥ s·ª≠ d·ª•ng STUN/TURN kh√¥ng
                peer.on('iceStateChanged', state => {
                    console.log(`üîÑ Tr·∫°ng th√°i ICE: ${state}`);
                });

                peer.on('iceConnectionStateChange', () => {
                    console.log(
                        `üì° K·∫øt n·ªëi ICE hi·ªán t·∫°i: ${peer.iceConnectionState}`
                    );
                });

                peer.on('iceCandidate', event => {
                    if (event.candidate) {
                        console.log(
                            `üü¢ ICE Candidate nh·∫≠n ƒë∆∞·ª£c:`,
                            event.candidate
                        );
                    } else {
                        console.log('üöÄ ICE Candidate ƒë√£ ho√†n t·∫•t.');
                    }
                });
            });

            peer.on('call', call => {
                call.answer(localStreamRef.current);
                call.on('stream', remoteStream => {
                    addVideo(call.peer, remoteStream);
                });
            });
        };

        // H√†m l·∫•y stream video v√† audio t·ª´ user
        const getMediaStream = async () => {
            try {
                // Ki·ªÉm tra quy·ªÅn truy c·∫≠p camera
                const permissionStatus = await navigator.permissions.query({
                    name: 'camera'
                });

                // N·∫øu quy·ªÅn ch∆∞a ƒë∆∞·ª£c c·∫•p ho·∫∑c t·ª´ ch·ªëi, y√™u c·∫ßu ng∆∞·ªùi d√πng c·∫•p quy·ªÅn
                if (permissionStatus.state !== 'granted') {
                    const userConsent = window.confirm(
                        'B·∫°n c√≥ mu·ªën c·∫•p quy·ªÅn s·ª≠ d·ª•ng camera kh√¥ng?'
                    );
                    if (!userConsent) {
                        throw new Error(
                            'Ng∆∞·ªùi d√πng kh√¥ng c·∫•p quy·ªÅn s·ª≠ d·ª•ng camera.'
                        );
                    }
                }

                // Ti·∫øn h√†nh l·∫•y stream t·ª´ camera
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: true,
                    audio: true
                });
                return stream; // Tr·∫£ v·ªÅ stream n·∫øu th√†nh c√¥ng
            } catch (error) {
                console.error('Kh√¥ng th·ªÉ truy c·∫≠p camera/mic:', error);
                return null; // Tr·∫£ v·ªÅ null n·∫øu g·∫∑p l·ªói
            }
        };

        //c·∫≠p nh·∫≠t danh s√°ch ng∆∞·ªùi d√πng ƒë√£ k·∫øt n·ªëi

        const handleUpdateUserList = userList => {
            console.log(
                'üìå Danh s√°ch to√†n b·ªô th√†nh vi√™n ƒë√£ k·∫øt n·ªëi:',
                userList
            );
            setRemotePeers(userList);
        };
        //c·∫≠p nh·∫≠t danh s√°ch cu·ªôc h·ªçp

        const handleUpdateMeetingList = meetingList => {
            console.log('üìÖ Danh s√°ch cu·ªôc h·ªçp:', meetingList);
            setMeetings(meetingList);
        };

        //c·∫≠p nh·∫≠t danh s√°ch ng∆∞·ªùi tham gia cu·ªôc h·ªçp

        const handleUpdateMeetingParticipants = (meetingId, participants) => {
            console.log(
                `üìû Danh s√°ch ng∆∞·ªùi trong cu·ªôc h·ªçp ${meetingId}:`,
                participants
            );
            setCallParticipants(participants);

            // Khi danh s√°ch c·∫≠p nh·∫≠t, g·ªçi video ƒë·∫øn t·∫•t c·∫£ th√†nh vi√™n m·ªõi
            participants.forEach(participant => {
                if (
                    participant !== peerId &&
                    !videoRefs.current.some(video => video.id === participant)
                ) {
                    makeCall(peerRef.current, participant);
                }
            });
        };

        signalRRef.current = createSignalRConnection(
            handleReceiveConnectionId,
            handleUpdateUserList,
            handleUpdateMeetingList,
            handleUpdateMeetingParticipants
        );

        // Cleanup function khi component unmount
        return () => {
            // Ch·ªâ g·ªçi destroy n·∫øu peerRef.current l√† instance h·ª£p l·ªá c·ªßa Peer
            if (
                peerRef.current &&
                typeof peerRef.current.destroy === 'function'
            ) {
                peerRef.current.destroy(); // G·ªçi destroy ƒë√∫ng c√°ch
                peerRef.current = null; // Reset peerRef
            }
            if (signalRRef.current) {
                signalRRef.current.stop(); // D·ª´ng SignalR khi unmount
                signalRRef.current = null; // Reset signalRRef
            }
            // D·ª´ng t·∫•t c·∫£ c√°c tracks trong local stream
            if (localStreamRef.current) {
                localStreamRef.current
                    .getTracks()
                    .forEach(track => track.stop());
                localStreamRef.current = null; // Reset stream
            }
        };
    }, []);

    // T·∫°o cu·ªôc h·ªçp m·ªõi
    const createMeeting = () => {
        if (meetingId.trim() === '') {
            console.warn('‚ö†Ô∏è Vui l√≤ng nh·∫≠p ID cu·ªôc h·ªçp.');
            return;
        }

        signalRRef.current
            .invoke('CreateMeeting', meetingId)
            .then(() => alert(`üìÖ ƒê√£ t·∫°o cu·ªôc h·ªçp ${meetingId}`))
            .catch(err => alert('‚ö†Ô∏è Kh√¥ng th·ªÉ t·∫°o cu·ªôc h·ªçp:', err));
    };

    // Tham gia cu·ªôc h·ªçp v·ªõi ID c·ª• th·ªÉ
    const joinMeeting = () => {
        if (meetingId.trim() === '') {
            console.warn('‚ö†Ô∏è Vui l√≤ng nh·∫≠p ID cu·ªôc h·ªçp.');
            return;
        }

        signalRRef.current
            .invoke('JoinMeeting', meetingId)
            .then(() => {
                console.log(`‚úÖ ƒê√£ tham gia cu·ªôc h·ªçp ${meetingId}`);
            })
            .catch(err =>
                console.error('‚ö†Ô∏è Kh√¥ng th·ªÉ tham gia cu·ªôc h·ªçp:', err)
            );
    };

    // R·ªùi cu·ªôc h·ªçp hi·ªán t·∫°i (S·ª≠a l·ªói)
    const leaveMeeting = () => {
        if (meetingId.trim() === '') {
            console.warn('‚ö†Ô∏è Vui l√≤ng nh·∫≠p ID cu·ªôc h·ªçp ƒë·ªÉ r·ªùi.');
            return;
        }

        signalRRef.current
            .invoke('LeaveMeeting', meetingId)
            .then(() => {
                console.log(`üö™ ƒê√£ r·ªùi kh·ªèi cu·ªôc h·ªçp ${meetingId}`);

                // Ng·∫Øt k·∫øt n·ªëi PeerJS khi r·ªùi cu·ªôc g·ªçi
                if (peerRef.current) {
                    peerRef.current = null;
                }

                // X√≥a video c·ªßa ng∆∞·ªùi d√πng
                removeVideo(peerId);

                // C·∫≠p nh·∫≠t danh s√°ch ng∆∞·ªùi g·ªçi
                setCallParticipants(prev => prev.filter(pid => pid !== peerId));

                // T·∫Øt mic & camera
                if (localStreamRef.current) {
                    localStreamRef.current
                        .getTracks()
                        .forEach(track => track.stop());
                    localStreamRef.current = null;
                }
            })
            .catch(err => console.error('‚ö†Ô∏è Kh√¥ng th·ªÉ r·ªùi cu·ªôc h·ªçp:', err));
    };

    // G·ªçi ƒë·∫øn m·ªôt Peer trong ph√≤ng h·ªçp
    const makeCall = (peer, targetPeerId) => {
        if (
            !peer ||
            !localStreamRef.current ||
            videoRefs.current.some(video => video.id === targetPeerId)
        )
            return;

        console.log(`üìû G·ªçi ƒë·∫øn: ${targetPeerId}`);

        const call = peer.call(targetPeerId, localStreamRef.current);
        call.on('stream', remoteStream => {
            addVideo(targetPeerId, remoteStream);
        });
    };
    // H√†m l·∫•y stream video v√† audio t·ª´ user
    const getMediaStream = async () => {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({
                video: true,
                audio: true
            });
            return stream; // Tr·∫£ v·ªÅ stream n·∫øu th√†nh c√¥ng
        } catch (error) {
            console.error('Kh√¥ng th·ªÉ truy c·∫≠p camera/mic:', error);
            return null; // Tr·∫£ v·ªÅ null n·∫øu g·∫∑p l·ªói
        }
    };

    // Th√™m video v√†o giao di·ªán
    // H√†m th√™m video v·ªõi cleanup
    const addVideo = useCallback(
        (peerId_nhan, stream, isLocal = false) => {
            if (
                !videoContainerRef.current ||
                document.getElementById(peerId_nhan)
            )
                return;

            const video = document.createElement('video');
            video.srcObject = stream;
            video.autoplay = true;
            video.muted = isLocal;

            video.playsInline = true; // Quan tr·ªçng cho iOS

            video.id = peerId_nhan;

            console.log('peerid hien tai : ', peerId);

            video.className = cx('vuser', {
                you: isLocal
            });

            videoRefs.current[peerId_nhan] = video;
            videoContainerRef.current.appendChild(video);

            // Tr·∫£ v·ªÅ h√†m d·ªçn d·∫πp
            return () => {
                if (video.parentNode) {
                    video.parentNode.removeChild(video);
                }
                delete videoRefs.current[peerId_nhan];
                stream.getTracks().forEach(track => track.stop());
            };
        },
        [callParticipants, videoContainerRef]
    );
    // X√≥a video kh·ªèi giao di·ªán khi r·ªùi cu·ªôc h·ªçp
    const removeVideo = peerId => {
        const videoIndex = videoRefs.current.findIndex(
            video => video.id === peerId
        );

        if (videoIndex !== -1) {
            const video = videoRefs.current[videoIndex];

            video.pause();
            video.srcObject = null;
            video.remove();

            videoRefs.current.splice(videoIndex, 1);
        }
    };
    return (
        <CallContext.Provider
            value={{
                peerId,
                remotePeers,
                callParticipants,
                meetings,
                meetingId,
                videoRefs,
                setMeetingId,
                createMeeting,
                joinMeeting,
                leaveMeeting,
                localStreamRef,
                videoContainerRef,
                getMediaStream,
                addVideo
            }}
        >
            {children}
        </CallContext.Provider>
    );
}

export { CallContext, CallFixProvider };
